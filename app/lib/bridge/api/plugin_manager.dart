// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.8.0.

// ignore_for_file: require_trailing_commas
// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: avoid_dynamic_calls
// ignore_for_file: avoid_equals_and_hash_code_on_mutable_classes
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: inference_failure_on_instance_creation

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:stride/bridge/api/error.dart';
import 'package:stride/bridge/frb_generated.dart';
import 'package:stride/bridge/third_party/stride_core/event.dart';
import 'package:stride/bridge/third_party/stride_core/task.dart';
import 'package:stride/bridge/third_party/stride_core/task/annotation.dart';
import 'package:stride/bridge/third_party/stride_plugin_manager/manifest.dart';
import 'package:uuid/uuid.dart';

Future<void> load({required String pluginPath}) =>
    RustLib.instance.api.crateApiPluginManagerLoad(pluginPath: pluginPath);

Future<void> emit({required HostEvent event}) =>
    RustLib.instance.api.crateApiPluginManagerEmit(event: event);

Future<bool> processHostEvent() =>
    RustLib.instance.api.crateApiPluginManagerProcessHostEvent();

Future<PluginAction?> processPluginEvent() =>
    RustLib.instance.api.crateApiPluginManagerProcessPluginEvent();

Future<void> import_({required String filepath}) =>
    RustLib.instance.api.crateApiPluginManagerImport(filepath: filepath);

Future<bool> remove({required String pluginName}) =>
    RustLib.instance.api.crateApiPluginManagerRemove(pluginName: pluginName);

Future<bool> disable({required String pluginName, String? reason}) =>
    RustLib.instance.api
        .crateApiPluginManagerDisable(pluginName: pluginName, reason: reason);

Future<bool> toggle({required String pluginName}) =>
    RustLib.instance.api.crateApiPluginManagerToggle(pluginName: pluginName);

Future<List<PluginManifestPluginState>> pluginManifests() =>
    RustLib.instance.api.crateApiPluginManagerPluginManifests();

Future<PluginManifestPluginState> parsePlugin({required String filepath}) =>
    RustLib.instance.api.crateApiPluginManagerParsePlugin(filepath: filepath);
